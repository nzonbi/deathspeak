![deathspeak](http://nzonbi.github.io/deathspeak/deathspeak-w.svg)


# deathspeak

Experimental syntax design for a stylized, compact and expressive
programming language. Does not follow common syntax preconcemptions.


## Programming language concept

This project is an experimental concept design. The language is not
going to be implemented. After experimenting with the syntax, it was
found that the language is hard to read. Specially at first. With
enough practice, it can works. But it doesn't seem practical.

## note

The deathspeak language employs standard language features,  
but the syntax does not follow common convetions from other  
languages, so it may not seems easy to read at first.  

## about

Symbols characters have great expressive power, that can  
succinctly convey ideas. okami is based on the _subjetive_  
perception, that programming languages have left untapped  
potential, in the expressive power of symbols.

deathspeak is an attemp to maximize representation of precise and  
clear concepts, with the expressive power of symbols. It is  
also part of a research project in software design, with  
goals that will be presented in the future.

deathspeak is built on top of javascript, because Javascript is  
rapidly becoming an impressive language, in terms of spread and  
recently even in performance. And in its quirks, has many hidden  
gems of expressive power. But suffers from historical baggage  
and of having to please everyone.

## goals

### main goals:

* language based on simple, and precise concepts.
* compiles to readable javascript.
* work easily side by side with javascript.
* syntax based on symbols, designed to be compact, and maximize 
  expressive power, bypassing any preconceptions.

### syntax goals

deathspeak syntax bypass any preconceptions, so it may not be
easy at first. it is designed with these goals:

* compact: avoid syntax noise, repetition and thrash.
* expressive: agile syntax of expressions.
* easy to read: compact and noise free syntax that is easier to read.
* easy to write: agile and compact syntax that is easier to write.
* simple: based on simple, precise and coherent concepts.
* comfortable: smaller conceptual footprint for reduced programmer stress.

## license

MIT license









