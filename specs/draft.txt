:: okami ::

minimalist programming language,
on top of javascript.

v 0.01 initial specs.
this document is a working draft


simple, clean, expressive, compact syntax.
often less is more.








:::::::::::::::::::::::::::
:: comments ::

:: this is a comment line



:::::::::::::::::::::::::::
:: assignment :

a: 2



:::::::::::::::::::::::::::
:: function !

a:! 
	a:1



:: function call:

a!



:: return
:: ^ is the return symbol

a: ! 
	a: 1			
	b: 2		
	^ a + b		

a!					:: returns 3


:: in a function the last expression
:: is returned, by default

a: ! 2+3
a!					:: returns 5



:: function with parameter
:: only one parameter is allowed

a! par

walk! 4				



:: accesing parameters

walk: !
	# + " steps"		:: # is the parameter object	

walk! 4					:: returns "4 steps"



:: multiple parameters

talk: !
	a: #noun			
	b: #verb			:: properties of the parameter object
	a + ' ' + b

talk! @ noun: "cat", verb: "mews"		:: returns "cat mews"
										:: parameter is an object
										:: (see object)
										:: @todo comma as expression 



:: function context 

a: ! #a+#b+c

:: the next paragraph is discarded

:: drop :: from where comes "c"??
:: drop :: functions run on their own unique context,
:: drop :: except if they are attached to an object.
:: drop :: when attached into an object, the context 
:: drop :: is the one from the object,
:: drop :: so "c" is equivalent to this.c in that case.
:: drop :: when the context is an object, see "methods"
:: drop :: for additional details

:: drop :: function context, revision 2: (discarded too)
::
:: drop :: functions run on their own context, but any
:: drop :: variables used, that is also used in the the
:: drop :: inmediately superior context ( where the function
:: drop :: was defined ) is referenced from there.
:: drop :: @todo: review this

:: drop :: pros:
:: drop :: - methods can refence object variables
:: drop :: without requiring a "this"
::
:: drop :: cons:
:: drop :: - encourage bad practices

b: @ 
	a:1 b:2 
	c:! a + b				

b: @ 
	a:1 b:2 
	c:! *a + *b

b: @ 
	a:1 b:2 
	c:! @a + @b


:: decided:
::
:: define two concepts:
:: ! function
:: @! method



:: functions scope

:: functions are pure functions, with no side
:: effects. 
:: The function scope is closed. The function 
:: parameter is the only external data available.



:: closures
:: is not possible to form closures using functions.
:: closures can be formed with methods.
:: function and method are two different things.

x: "something"
a: ! 
	a: x		:: a is assigned "undefined"






:::::::::::::::::::::::::::
:: objects @

a: @
	a: 1					:: public

	*a: 2					:: private
	*b: 3	
	
	c: a + *b				:: object definition is also
							:: an execution context.
							:: "c" is assigned 4.

	*c: *a + *b + a + b		:: private and public are separated
							:: namespaces. repeated names allowed
							:: @todo: is this a good idea?
							:: - yes, for getters and setters

					

:: methods @!
:: 
:: methods are different from functions.
:: functions are pure functions for functional programming.
:: methods, are function closures, taking any variable named
:: in their container scope.
::

x:2

b: @
	a: 1
	b: 2

	c: @! a + b
	c!				:: return 3

	d: @! x					
	d!				:: returns 2



:: "this"
::
::
:: * is the "this" object (bound this)
:: (* is also is the private var namespace)
::
:: ~ "dynamic" this
:: an ~ is the current object to which the method 
:: is attached at the moment of the call

o: @
	a:	1
	b:  4
	*a:	2				:: private variable
		
	e:	@! *a + a		:: will return 3

	f: @! a + b			:: will return 5


	c:	@! ~a + ~*a		:: will return 3, unless the method
						:: is attached into another object.
						:: in that case, ~ refers to the 
						:: current host object, and the vars
						:: are evaluated to that object.


	d:	@! *			:: will return the object itself
						:: * is "this" (bound this)
	
	e:	@! ~			:: will return the object to which
						:: the method is currently attached 
						:: ~ is "this" (javascript this)



:: functions in objects
::
:: functions (pure functions) can also be attached to
:: objects


o: @
	a: 1	
	b: ! a

	b!				:: returns undefined


	
			


:: prototype
::
:: prototype objects are assigned with 
:: the add prototype operator (+)

a: @ (+)b			:: defines an object "a",
					:: and assign object"b" as a prototype




:::::::::::::::::::::::::::
:: classes (not really)
:: just a function that return objects

classA: !@ 					:: this is valid syntax for a function
							:: that return objects

	(+) classB				:: prototype
	(+) classC				:: prototype
							:: order is important
							:: later ones overwrite existing members

	b: #par					:: #par parameter in the constructor 
							:: function

	a:1						:: public
	b:2

	*c:	3 					:: * marks variables as private

	*d:	! fruit: "apple" 	:: function (private)
							:: fruit only exist inside the function




:::::::::::::::::::::::::::
:: getters and setters (not really)
:: just methods

a: @
	*a: 0
	
	a: @! 
		#? *a = #				:: setter
		/  "this is " + *a		:: getter


a!2								:: a is assigned 2.

a!								:: returns "this is 2"


:: proposed syntax for getter setters

:: split method definition


a: @
	*a: 0
	
	a: @!#					:: method with parameter
		*a = #				:: setter

	a: @!/					:: method without parameter
		"this is " + *a		:: getter




:::::::::::::::::::::::::::
:: conditional

a=b ?			:: if
	"one"
/ a>b ?			:: else if
	"two"
/				:: else
	"three"

:: used as an expression

x:1
a: x=1? 2					:: a is 2
b: x=2? 3					:: b is false

ab: a=b? "yes" /? "no"		:: ab is "no"


:::::::::::::::::::::::::::
:: loops

a: 0
<> a=5?
	a++	
	"hello"						:: "hello" five times


<>5 "hello"						:: hello five times

<>['a','b','c'] " val: " + #	:: "val a val b val c"

:::::::::::::::::::::::::::
:: operators

= equality

logical:
& and
| or
>< not

binary:
`&
`|
`><

